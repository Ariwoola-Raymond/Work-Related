<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SR Extractor (Excel-proof)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a2b; --muted:#6b7a99; --text:#e6ecff; --accent:#7aa2ff; --accent-2:#22c55e; --warn:#f59e0b; --danger:#ef4444;
      --border:#22304d; --chip:#1a2440; --chip-text:#d2dcff; --card:#0f1628; --shadow:rgba(10,14,25,.35);
    }
    *{box-sizing:border-box}
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; color:var(--text); background: radial-gradient(1200px 600px at 10% -10%, #16213a, transparent 60%), radial-gradient(1200px 600px at 110% 10%, #101a32, transparent 60%), var(--bg); }
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg, rgba(11,16,32,.95) 0%, rgba(11,16,32,.75) 100%);backdrop-filter: blur(6px); border-bottom:1px solid var(--border)}
    .wrap{max-width:1100px;margin:0 auto;padding:16px 20px}
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px 16px; box-shadow: 0 6px 18px var(--shadow)}
  .controls{ display:grid; grid-template-columns: 1.2fr 1fr; gap:12px; }
    .controls .group{ background:var(--card); border:1px solid var(--border); padding:12px; border-radius:10px }
    .controls h4{margin:0 0 8px 0;color:#cbd6ff;font-weight:600}
  label{ display:flex; align-items:center; gap:8px; color:var(--muted); font-size:13px }
    input[type="text"], input[type="number"], select{ background:#0c1326; border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; min-width: 260px }
    input[type="checkbox"]{ transform: translateY(1px) }
    button { padding: 10px 14px; cursor: pointer; border-radius:9px; border:1px solid var(--border); background: linear-gradient(180deg,#18264a,#14203f); color:var(--text) }
    button.primary{ background: linear-gradient(180deg, #1a3a7a, #162e61); border-color:#1f3d74 }
    button.success{ background: linear-gradient(180deg, #1d6f46, #135a39); border-color:#1b6141 }
    button:disabled{ opacity:.5; cursor:not-allowed }

    .badges{display:flex; gap:6px; flex-wrap: wrap}
    .badge{ background:var(--chip); color:var(--chip-text); border:1px solid var(--border); padding:4px 8px; font-size:12px; border-radius:999px }

    .results{ margin-top:16px; display:grid; grid-template-columns: repeat(auto-fill,minmax(320px,1fr)); gap:14px }
    .card{ background:linear-gradient(180deg, #121b32, #0f1628); border:1px solid var(--border); border-radius:12px; padding:12px; box-shadow: 0 8px 22px var(--shadow) }
    .card h3{ margin:0 0 6px 0; font-size:16px; color:#eaf1ff }
    .meta{ color:var(--muted); font-size:12px; display:flex; gap:8px; flex-wrap: wrap }
    .preview{ border-top:1px dashed var(--border); margin-top:8px; padding-top:8px }
    table.previewTable{ width:100%; border-collapse: collapse; font-size:12px }
    .previewTable th, .previewTable td{ border-bottom:1px solid var(--border); padding:6px 8px; text-align:left; vertical-align: top; }
    .previewTable th{ color:#cbd6ff; background:#101733 }
    .chip{ padding:2px 8px; border-radius:999px; font-size:11px; border:1px solid var(--border); background:#0e1934; color:#cfe0ff }
  .chips{ display:flex; flex-wrap:wrap; gap:6px; margin-top:8px }
  .chip-btn{ display:inline-flex; gap:6px; align-items:center; padding:4px 8px; background:#102048; color:#d8e4ff; border:1px solid #253863; border-radius:999px; font-size:12px }
  .chip-btn button{ background:transparent; border:none; color:#9db7ff; cursor:pointer; padding:0 4px }
  .chip-input{ display:flex; gap:8px; margin-top:8px }
  .chip-input input{ flex:1 }
  .preset-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .preset-row select{ min-width:220px }
  .bulk-panel{ display:none; margin-top:8px }
  .bulk-panel textarea{ width:100%; min-height:90px; background:#0c1326; color:#e6ecff; border:1px solid var(--border); border-radius:8px; padding:8px }
  .hit{ background:#365bd6; color:#eaf1ff; padding:0 3px; border-radius:3px }
    .footer-actions{ display:flex; gap:10px; align-items:center; justify-content: space-between; margin-top:10px }
    .stat{ color:#cfe0ff; font-size:12px }
    /* Table view */
    .resultsToolbar{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content: space-between; margin-top:14px }
    .segmented{ display:inline-flex; border:1px solid var(--border); border-radius:10px; overflow:hidden }
    .segmented button{ background:#0f1a33; border:none; color:#cfe0ff; padding:8px 12px; cursor:pointer }
    .segmented button.selected{ background:#1b2b56 }
    .tableWrap{ margin-top:10px; border:1px solid var(--border); border-radius:10px; overflow:auto; max-height: 65vh; background:#0d1630 }
    table.dataTable{ width:100%; border-collapse: collapse; font-size:12px; }
    .dataTable th, .dataTable td{ border-bottom:1px solid var(--border); padding:8px 10px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
    .dataTable th{ position:sticky; top:0; background:#111c3d; color:#eaf1ff; cursor:pointer; }
    .dataTable tr:nth-child(even){ background:#0e1834 }
    .dataTable tr:hover{ background:#152046 }
    .paginate{ display:flex; gap:8px; align-items:center }
    .paginate button{ padding:6px 10px }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <strong style="font-size:18px">SR Extractor Pro</strong>
          <span class="badge">Excel-proof UTF‑8</span>
          <span class="badge">Messy-table tolerant</span>
        </div>
        <div class="row">
          <button id="downloadBtn" class="success" disabled onclick="downloadCurrentCSV()">Download CSV</button>
        </div>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="row">
        <input id="fileInput" type="file" multiple accept=".html"/>
        <button id="runBtn" class="primary" onclick="processFiles()">Process</button>
        <span id="progress" class="stat"></span>
      </div>
      <div class="controls" style="margin-top:12px">
        <div class="group">
          <h4>Extraction Options</h4>
          <div class="row">
            <label><input type="checkbox" id="optReuseScenario" checked/>Reuse Contingency for Scenario</label>
            <label><input type="checkbox" id="optSanitize" checked/>Excel sanitize punctuation</label>
            <label><input type="checkbox" id="optFilterSR" checked/>Apply SR keyword filter</label>
            <label><input type="checkbox" id="optKeepOnlyMatching"/>Keep only matching rows</label>
            <label><input type="checkbox" id="optExcludeSparse" checked/>Exclude 1–2 column tables</label>
            <label>Min matches per table
              <input type="number" id="optMinMatches" min="1" value="1" style="width:80px"/>
            </label>
          </div>
        </div>
        <div class="group">
          <h4>SR Filter Keywords</h4>
          <div class="preset-row">
            <select id="keywordPresetSelect" onchange="onPresetChange(this.value)"></select>
            <button onclick="saveCustomPreset()">Save as Custom</button>
            <button onclick="resetToDefaultPreset()">Reset to Default</button>
            <button onclick="triggerImportKeywords()">Import JSON</button>
            <button onclick="exportKeywords()">Export JSON</button>
            <button onclick="toggleBulkPanel()">Bulk Paste</button>
            <input id="keywordImportFile" type="file" accept="application/json,.json" style="display:none"/>
          </div>
          <div class="chip-input">
            <input type="text" id="keywordInput" placeholder="Add keyword (supports * prefix, Enter to add)"/>
            <button onclick="addKeywordFromInput()">Add</button>
          </div>
          <div id="keywordChips" class="chips"></div>
          <div id="bulkPastePanel" class="bulk-panel">
            <textarea id="bulkTextarea" placeholder="Paste keywords here (space or comma-separated)"></textarea>
            <div class="row" style="margin-top:6px">
              <button onclick="applyBulkKeywords()">Apply</button>
              <button onclick="toggleBulkPanel()">Close</button>
            </div>
          </div>
          <div class="row" style="margin-top:6px">
            <span class="stat">Matches in Type primarily; * means prefix</span>
          </div>
        </div>
      </div>
    </div>

    <div class="footer-actions">
      <div class="badges">
        <span class="badge" id="statFiles">No files</span>
        <span class="badge" id="statTables">No tables</span>
        <span class="badge" id="statRows">No rows</span>
      </div>
      <div class="row">
        <button id="downloadBtn2" class="success" disabled onclick="downloadCurrentCSV()">Download CSV</button>
      </div>
    </div>

    <div class="resultsToolbar">
      <div class="segmented">
        <button id="btnViewTable" class="selected" onclick="setViewMode('table')">Table</button>
        <button id="btnViewCards" onclick="setViewMode('cards')">Cards</button>
      </div>
      <div class="row">
        <input id="globalFilter" type="text" placeholder="Search results" oninput="onFilterChange(this.value)"/>
        <label>Rows per page
          <select id="pageSize" onchange="onPageSizeChange(this.value)">
            <option>25</option>
            <option selected>50</option>
            <option>100</option>
            <option>200</option>
          </select>
        </label>
        <div class="paginate">
          <button onclick="prevPage()">Prev</button>
          <span id="pageInfo" class="stat"></span>
          <button onclick="nextPage()">Next</button>
        </div>
      </div>
    </div>
    <div id="results" class="results"></div>
    <div id="resultsTableWrap" class="tableWrap" style="display:none"></div>
  </div>

  <script>

/** =========================
 *  CONFIG (controlled via UI)
 *  ========================= */
let REUSE_CONTINGENCY_FOR_SCENARIO = true;
let ENABLE_EXCEL_SANITIZE = true;
let APPLY_SR_KEYWORD_FILTER = true;
let SR_KEYWORDS = ['comp*','cco*','internal*','misc*','serv*','balance*','billed*','card*','cash*','cheque*','credit*','email*','enable*','statement*','installment*','ipp*','west*']; // supports * prefix wildcard
let KEEP_ONLY_MATCHING_ROWS = false;
let EXCLUDE_SPARSE_TABLES = true;
let MIN_MATCHING_ROWS = 1;

const DEFAULT_PRESET = {
  id: 'default',
  name: 'Default (curated)',
  keywords: [...SR_KEYWORDS]
};
const MINIMAL_PRESET = {
  id: 'minimal',
  name: 'Minimal (core terms)',
  keywords: ['comp*','serv*','card*']
};
const STRICT_PRESET = {
  id: 'strict',
  name: 'Strict (curated full)',
  keywords: [...SR_KEYWORDS]
};
const EVERYTHING_PRESET = {
  id: 'everything',
  name: 'Everything (no filter)',
  keywords: []
};
const PRESET_STORAGE_KEY = 'srExtractorPresetsV1';
const CUSTOM_PRESET_ID = 'custom';
let PRESETS = [];
let VIEW_MODE = 'table';
const TABLE_STATE = { filter: '', sortIndex: null, sortDir: 'asc', page: 1, perPage: 50 };

// Runtime aggregation
let CURRENT_RESULTS = []; // Array<{ id, meta, rows, include }>
let AGG_ROWS = []; // flattened rows for CSV

/** =========================
 *  MAIN
 *  ========================= */
async function processFiles() {
  const fileInput = document.getElementById('fileInput');
  const files = fileInput?.files || [];
  if (!files.length) { alert('Please select files to process'); return; }

  // Read options from UI
  REUSE_CONTINGENCY_FOR_SCENARIO = document.getElementById('optReuseScenario').checked;
  ENABLE_EXCEL_SANITIZE = document.getElementById('optSanitize').checked;
  APPLY_SR_KEYWORD_FILTER = document.getElementById('optFilterSR').checked;
  KEEP_ONLY_MATCHING_ROWS = document.getElementById('optKeepOnlyMatching').checked;
  EXCLUDE_SPARSE_TABLES = document.getElementById('optExcludeSparse').checked;
  MIN_MATCHING_ROWS = Math.max(1, parseInt(document.getElementById('optMinMatches').value, 10) || 1);
  SR_KEYWORDS = getCurrentKeywords();

  CURRENT_RESULTS = [];
  AGG_ROWS = [];
  setStats({ files: files.length, tables: 0, rows: 0 });
  setProgress('Processing…');
  toggleDownload(false);

  let totalTables = 0;
  let totalRows = 0;

  for (const file of files) {
    const html = await readFile(file);
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");

    const tables = doc.querySelectorAll("table");
  tables.forEach((table, tIndex) => {
      // ---------- METADATA (Title / ID / Location-Category) ----------
      const title = findMetaNearby(table, "title") || "Unknown Title";
      const articleId = findMetaNearby(table, "id") || "Unknown ID";
      const articleCategory = findMetaNearby(table, "location") || "Unknown Category";
      const cleanArticleCategory = extractKey(articleCategory) ?? articleCategory;
      const entity = (cleanArticleCategory.split("_")[0] || "").trim();
      const articleURL = `https://askkmpro.sso.verint-km.com/enterprise/${entity}/${cleanArticleCategory}/${articleId}`;

      // ---------- HEADER MAPPING ----------
      const map = buildColumnMapEnhanced(table);
      if (!map) return; // unrecoverable

      // Gather rows (support tables that lack <tbody>)
      const bodyRows = table.querySelectorAll("tbody tr");
      const rows = bodyRows.length ? bodyRows : table.querySelectorAll("tr");

      // Early sparse table exclusion if enabled
      if (EXCLUDE_SPARSE_TABLES && isSparseTable(rows)) {
        return;
      }
      // Evaluate SR-likeness and row-level matches
      const evalRes = evaluateTable(rows, map);
      if (APPLY_SR_KEYWORD_FILTER && !evalRes.qualifies) {
        return; // skip non-SR tables per rules
      }

      const isFlagged = table.classList.contains("serviceRequest") ? "YES" : "NO";
      const extracted = [];

      rows.forEach(tr => {
        const tds = tr.querySelectorAll("td");
        if (!tds.length) return;
        // Skip header-ish rows inside tbody or body when tables are messy
        const headerishCells = tr.querySelectorAll('td,th');
        if (rowLooksLikeHeader(headerishCells)) return;

        // If enabled, keep only rows that matched the SR keywords
        if (APPLY_SR_KEYWORD_FILTER && KEEP_ONLY_MATCHING_ROWS) {
          const isMatch = evalRes.matchMap.get(tr) === true;
          if (!isMatch) return;
        }

        const pick = (idx) => {
          const td = tds[idx];
          return td ? normalizeCell(td) : "";
        };

        // Extract core SR fields with safety
        const type    = safePick(pick, map.idx.type);
        const area    = safePick(pick, map.idx.area);
        const subArea = safePick(pick, map.idx.subArea);
        const tat     = safePick(pick, map.idx.tat);

        // Scenario handling
        let scenario = "";
        if (map.idx.scenario != null) {
          scenario = safePick(pick, map.idx.scenario);
        } else if (map.offsetScenario && tds.length > 0) {
          scenario = normalizeCell(tds[0]);
        }

        // Contingency (if a real column exists)
        let contingency = "";
        if (map.idx.contingency != null) contingency = safePick(pick, map.idx.contingency);

        // New SR Template detection (by mapped header or heuristics per row)
        let newSrTemplate = "";
        if (map.idx.newSrTemplate != null) {
          newSrTemplate = safePick(pick, map.idx.newSrTemplate);
        } else {
          newSrTemplate = detectTemplateCell(tr) || "";
        }

        // Skip obviously empty SR rows (no core fields)
        if (!type && !area && !subArea && !tat && !contingency && !scenario && !newSrTemplate) return;

        // Title path normalization
        const titlePath = (title || "").replace(/\s*-\s*/g, "/").replace(/\s+/g, " ").trim();

        const rowObj = {
          entity,
          cleanArticleCategory,
          titlePath,
          articleId,
          articleURL,
          type,
          area,
          subArea,
          tat,
          scenario,
          contingency,
          newSrTemplate,
          isFlagged
        };
        extracted.push(rowObj);
      });

      if (!extracted.length) return;

      const id = `${file.name}#${tIndex}`;
      CURRENT_RESULTS.push({
        id,
        include: true,
        meta: { fileName: file.name, title, articleId, cleanArticleCategory, entity, articleURL },
        rows: extracted
      });
      totalTables += 1;
      totalRows += extracted.length;
    });
  }

  renderResults();
  setStats({ files: files.length, tables: totalTables, rows: totalRows });
  setProgress(totalTables ? `Found ${totalTables} SR table${totalTables>1?'s':''}` : 'No SR tables found');
  toggleDownload(totalTables > 0);
}

/** =========================
 *  COLUMN MAPPING & HEURISTICS
 *  ========================= */
function buildColumnMapEnhanced(table) {
  // Collect a candidate header row: thead if present, else first row if it looks header-ish
  const theadCells = table.querySelectorAll("thead tr th, thead tr td");
  let headerCells = theadCells.length ? theadCells : null;

  if (!headerCells) {
    const firstRow = table.querySelector("tr");
    if (firstRow) {
      const cells = firstRow.querySelectorAll("td,th");
      if (rowLooksLikeHeader(cells)) headerCells = cells;
    }
  }

  const want = {
    type:        /(^(request\s*)?type$)|(^type$)/i,
    area:        /^area$/i,
    subArea:     /^(sub[\s-]*area|sub[\s-]*type)$/i,
    tat:         /^tat$/i,
    contingency: /^contingency$/i,
    scenario:    /^scenario$/i,
    newSrTemplate: /(new\s*sr\s*template|new\s*service\s*request\s*template|^template$)/i
  };

  const idx = {
    type: null,
    area: null,
    subArea: null,
    tat: null,
    contingency: null,
    scenario: null,
    newSrTemplate: null
  };

  if (headerCells) {
    [...headerCells].forEach((cell, i) => {
      const t = normalizeText(cell.textContent);
      if (want.type.test(t)) idx.type = i;
      else if (want.area.test(t)) idx.area = i;
      else if (want.subArea.test(t)) idx.subArea = i;
      else if (want.tat.test(t)) idx.tat = i;
      else if (want.contingency.test(t)) idx.contingency = i;
      else if (want.scenario.test(t)) idx.scenario = i;
      else if (want.newSrTemplate.test(t)) idx.newSrTemplate = i;
    });
  }

  // If core fields aren’t mapped, infer by offset (skip Scenario-like first col)
  let offsetScenario = false;
  const bodyRows = table.querySelectorAll("tbody tr");
  const rows = bodyRows.length ? bodyRows : table.querySelectorAll("tr");
  if ((idx.type == null || idx.area == null || idx.subArea == null) && rows.length) {
    const firstRowWithTds = [...rows].find(r => r.querySelectorAll('td').length);
    const firstCells = firstRowWithTds ? firstRowWithTds.querySelectorAll('td') : [];
    const n = firstCells.length;

    if (n >= 4 && looksLikeScenarioCell(normalizeCell(firstCells[0]))) {
      offsetScenario = true;
      idx.type = idx.type ?? 1;
      idx.area = idx.area ?? 2;
      idx.subArea = idx.subArea ?? 3;
      idx.tat = idx.tat ?? (n > 4 ? 4 : null);
    } else if (n === 3) {
      // 3-column minimal tables: Type | Area | Sub Area
      idx.type = idx.type ?? 0;
      idx.area = idx.area ?? 1;
      idx.subArea = idx.subArea ?? 2;
      idx.tat = idx.tat ?? null;
    } else if (n >= 4) {
      // Assume Type | Area | Sub Area | TAT
      idx.type = idx.type ?? 0;
      idx.area = idx.area ?? 1;
      idx.subArea = idx.subArea ?? 2;
      idx.tat = idx.tat ?? 3;
    } else if (n === 2) {
      // Very sparse, still try to capture Type/Area
      idx.type = idx.type ?? 0;
      idx.area = idx.area ?? 1;
      idx.subArea = idx.subArea ?? null;
      idx.tat = idx.tat ?? null;
    } else if (n === 1) {
      // Single column, treat as Type
      idx.type = idx.type ?? 0;
    }
  }

  // Minimal requirement: at least one of the core fields (preferably Type)
  if (idx.type == null && idx.area == null && idx.subArea == null) return null;

  return { idx, offsetScenario };
}

function rowLooksLikeHeader(cells) {
  const texts = [...cells].map(c => normalizeText(c.textContent));
  const score =
    (texts.some(t => /(^(request\s*)?type$)|(^type$)/i.test(t)) ? 1 : 0) +
    (texts.some(t => /^area$/i.test(t)) ? 1 : 0) +
    (texts.some(t => /^(sub[\s-]*area|sub[\s-]*type)$/i.test(t)) ? 1 : 0);
  return score >= 2; // at least two header keywords present
}

function looksLikeScenarioCell(t) {
  if (!t) return false;
  // Heuristics: long sentence-like text (e.g., “Customer is facing an issue …”)
  return t.length > 25 || /\.\s|:|,|\(|\)/.test(t);
}

/** =========================
 *  SR FILTERING & RENDERING
 *  ========================= */
function tableLooksLikeSR(rows, map) {
  // Prefer scanning Type column values
  const typeIdx = map.idx.type;
  if (typeIdx != null) {
    for (const tr of rows) {
      const tds = tr.querySelectorAll('td');
      if (!tds.length) continue;
      const val = normalizeCell(tds[typeIdx]).toLowerCase();
      if (val && matchesKeywords(val)) return true;
    }
    return false;
  }
  // Fallback: scan all cells (coarser)
  for (const tr of rows) {
    const tds = tr.querySelectorAll('td');
    for (const td of tds) {
      const val = normalizeCell(td).toLowerCase();
      if (val && matchesKeywords(val)) return true;
    }
  }
  return false;
}

// Stricter evaluator with row-level match map and thresholds
function evaluateTable(rows, map){
  const res = { qualifies: true, matchCount: 0, totalRows: 0, matchMap: new Map() };
  // Optionally exclude sparse tables (1–2 columns) before matching
  if (EXCLUDE_SPARSE_TABLES) {
    const firstRow = [...rows].find(r => r.querySelectorAll('td').length);
    const n = firstRow ? firstRow.querySelectorAll('td').length : 0;
    if (n > 0 && n <= 2) {
      res.qualifies = false;
      return res;
    }
  }
  const typeIdx = map.idx.type;
  for (const tr of rows) {
    const cells = tr.querySelectorAll('td,th');
    if (!cells.length) continue;
    if (rowLooksLikeHeader(cells)) continue;
    res.totalRows += 1;
    let matched = false;
    if (APPLY_SR_KEYWORD_FILTER) {
      if (typeIdx != null) {
        const tds = tr.querySelectorAll('td');
        if (tds.length > typeIdx) {
          const val = normalizeCell(tds[typeIdx]).toLowerCase();
          if (val && matchesKeywords(val)) matched = true;
        }
      } else {
        // fallback: scan all tds
        const tds = tr.querySelectorAll('td');
        for (const td of tds) {
          const val = normalizeCell(td).toLowerCase();
          if (val && matchesKeywords(val)) { matched = true; break; }
        }
      }
    }
    res.matchMap.set(tr, matched);
    if (matched) res.matchCount += 1;
  }
  if (APPLY_SR_KEYWORD_FILTER) {
    res.qualifies = res.matchCount >= MIN_MATCHING_ROWS;
  }
  return res;
}

function parseKeywords(str){
  return (str || '')
    .split(/[\s,]+/)
    .map(s => s.trim().toLowerCase())
    .filter(Boolean)
    .filter((v, i, a) => a.indexOf(v) === i); // dedupe
}

function matchesKeywords(val){
  for (const kw of SR_KEYWORDS) {
    if (!kw) continue;
    if (kw === '*') return true;
    if (kw.endsWith('*')) {
      const prefix = kw.slice(0, -1);
      if (prefix && val.includes(prefix)) return true;
    } else {
      if (val.includes(kw)) return true;
    }
  }
  return false;
}

/** =========================
 *  PRESETS & CHIPS UI
 *  ========================= */
function loadPresets(){
  try{
    const raw = localStorage.getItem(PRESET_STORAGE_KEY);
    const builtins = [DEFAULT_PRESET, MINIMAL_PRESET, STRICT_PRESET, EVERYTHING_PRESET];
    if (raw){
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)){
        const map = new Map();
        for (const p of builtins) map.set(p.id, p);
        for (const p of parsed) if (p && p.id) map.set(p.id, p);
        PRESETS = Array.from(map.values());
      } else {
        PRESETS = builtins;
      }
    } else {
      PRESETS = builtins;
    }
  }catch(e){ PRESETS = [DEFAULT_PRESET, MINIMAL_PRESET, STRICT_PRESET, EVERYTHING_PRESET]; }
  renderPresetSelect();
  // Select custom if exists else default
  const hasCustom = PRESETS.find(p => p.id === CUSTOM_PRESET_ID);
  const selectedId = hasCustom ? CUSTOM_PRESET_ID : 'default';
  setCurrentPreset(selectedId);
}

function savePresets(){
  try{ localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(PRESETS)); }catch(e){}
}

function renderPresetSelect(){
  const sel = document.getElementById('keywordPresetSelect');
  sel.innerHTML = '';
  PRESETS.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.id; opt.textContent = p.name; sel.appendChild(opt);
  });
}

function onPresetChange(presetId){
  setCurrentPreset(presetId);
}

function setCurrentPreset(presetId){
  const preset = PRESETS.find(p => p.id === presetId) || DEFAULT_PRESET;
  SR_KEYWORDS = preset.keywords.slice();
    // Everything preset disables filter checkbox, others enable it
    const isEverything = preset.id === 'everything';
    const filterToggle = document.getElementById('optFilterSR');
    if (filterToggle){
      filterToggle.checked = !isEverything;
    }
  renderChips();
  // Update select value to reflect current
  const sel = document.getElementById('keywordPresetSelect');
  if (sel) sel.value = preset.id;
}

function renderChips(){
  const holder = document.getElementById('keywordChips');
  holder.innerHTML = '';
  SR_KEYWORDS.forEach((kw, index) => {
    const el = document.createElement('span');
    el.className = 'chip-btn';
    const txt = document.createElement('span'); txt.textContent = kw;
    const btn = document.createElement('button'); btn.textContent = '×'; btn.title = 'Remove';
    btn.onclick = () => { removeKeyword(index); };
    el.appendChild(txt); el.appendChild(btn);
    holder.appendChild(el);
  });
}

function addKeywordFromInput(){
  const inp = document.getElementById('keywordInput');
  const raw = inp.value || '';
  const list = parseKeywords(raw);
  if (!list.length) return;
  for (const k of list){ addKeyword(k); }
  inp.value = '';
}

function addKeyword(kw){
  kw = (kw||'').toLowerCase().trim();
  if (!kw) return;
  if (!SR_KEYWORDS.includes(kw)){
    SR_KEYWORDS.push(kw);
    renderChips();
  }
}

function removeKeyword(idx){
  SR_KEYWORDS.splice(idx,1);
  renderChips();
}

function getCurrentKeywords(){
  return SR_KEYWORDS.slice();
}

function saveCustomPreset(){
  const existing = PRESETS.find(p => p.id === CUSTOM_PRESET_ID);
  if (existing){
    existing.keywords = getCurrentKeywords();
  } else {
    PRESETS.push({ id: CUSTOM_PRESET_ID, name: 'Custom', keywords: getCurrentKeywords() });
  }
  savePresets();
  renderPresetSelect();
  setCurrentPreset(CUSTOM_PRESET_ID);
}

function resetToDefaultPreset(){
  setCurrentPreset('default');
}

// Initialize presets/chips on load
window.addEventListener('DOMContentLoaded', () => {
  loadPresets();
  const input = document.getElementById('keywordInput');
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter'){ e.preventDefault(); addKeywordFromInput(); }
  });
});

function renderResults() {
  const cardsContainer = document.getElementById('results');
  const tableWrap = document.getElementById('resultsTableWrap');
  const btnTable = document.getElementById('btnViewTable');
  const btnCards = document.getElementById('btnViewCards');

  if (VIEW_MODE === 'table') {
    btnTable.classList.add('selected'); btnCards.classList.remove('selected');
    cardsContainer.style.display = 'none';
    tableWrap.style.display = 'block';
    renderResultsTable();
  } else {
    btnCards.classList.add('selected'); btnTable.classList.remove('selected');
    tableWrap.style.display = 'none';
    cardsContainer.style.display = 'grid';
    renderResultsCards();
  }
}

function renderResultsCards(){
  const container = document.getElementById('results');
  container.innerHTML = '';
  let totalRows = 0;
  CURRENT_RESULTS.forEach((item) => { totalRows += item.rows.length; });
  setStats({ rows: totalRows });
  CURRENT_RESULTS.forEach((item) => {
    const card = document.createElement('div');
    card.className = 'card';
    const m = item.meta;
    const title = document.createElement('h3');
    title.textContent = `${m.title || 'Untitled'} — ${m.fileName}`;
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `
      <span>ID: ${csvEscape(m.articleId)}</span>
      <span>Category: ${csvEscape(m.cleanArticleCategory)}</span>
      <span>Rows: ${item.rows.length}</span>
    `;
    const toggle = document.createElement('label');
    toggle.style.margin = '6px 0';
    const cb = document.createElement('input');
    cb.type = 'checkbox'; cb.checked = item.include;
    cb.onchange = () => { item.include = cb.checked; updateDownloadState(); renderResults(); };
    toggle.appendChild(cb);
    toggle.appendChild(document.createTextNode(' Include in CSV'));
    const preview = document.createElement('div'); preview.className = 'preview';
    const table = document.createElement('table'); table.className = 'previewTable';
    const thead = document.createElement('thead'); const thr = document.createElement('tr');
    headersForCSV().forEach(h => { const th = document.createElement('th'); th.textContent = h; thr.appendChild(th); });
    thead.appendChild(thr);
    const tbody = document.createElement('tbody');
    item.rows.slice(0,5).forEach(r => {
      const tr = document.createElement('tr');
      const cells = previewCellsFromRow(r);
      cells.forEach(cell => { const td = document.createElement('td'); if (cell.html) td.innerHTML = cell.html; else td.textContent = cell.value; tr.appendChild(td); });
      tbody.appendChild(tr);
    });
    table.appendChild(thead); table.appendChild(tbody); preview.appendChild(table);
    card.appendChild(title); card.appendChild(meta); card.appendChild(toggle); card.appendChild(preview);
    container.appendChild(card);
  });
}

function getIncludedRows(){
  const inc = CURRENT_RESULTS.filter(r => r.include);
  const rows = [];
  inc.forEach(item => item.rows.forEach(r => rows.push(r)));
  return rows;
}

function renderResultsTable(){
  const wrap = document.getElementById('resultsTableWrap');
  const headers = headersForCSV();
  const allRows = getIncludedRows();
  // Filtering
  const filter = (TABLE_STATE.filter || '').toLowerCase();
  let rows = !filter ? allRows : allRows.filter(r => Object.values(r).some(v => String(v||'').toLowerCase().includes(filter)));
  // Sorting
  if (TABLE_STATE.sortIndex != null){
    const idx = TABLE_STATE.sortIndex; const key = headers[idx];
    rows = rows.slice().sort((a,b)=>{
      const av = csvRowFromObj(a)[idx] || ''; const bv = csvRowFromObj(b)[idx] || '';
      return TABLE_STATE.sortDir === 'asc' ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
    });
  }
  // Pagination
  const per = TABLE_STATE.perPage; const total = rows.length; const pages = Math.max(1, Math.ceil(total / per));
  if (TABLE_STATE.page > pages) TABLE_STATE.page = pages;
  const start = (TABLE_STATE.page - 1) * per; const end = start + per;
  const pageRows = rows.slice(start, end);
  document.getElementById('pageInfo').textContent = `Page ${TABLE_STATE.page} / ${pages} — ${total} rows`;

  // Build table HTML
  const tbl = document.createElement('table'); tbl.className='dataTable';
  const thead = document.createElement('thead'); const thr = document.createElement('tr');
  headers.forEach((h, i)=>{
    const th = document.createElement('th'); th.textContent = h;
    th.onclick = () => onHeaderSort(i);
    if (TABLE_STATE.sortIndex === i){ th.textContent = h + (TABLE_STATE.sortDir==='asc' ? ' ▲' : ' ▼'); }
    thr.appendChild(th);
  });
  thead.appendChild(thr);
  const tbody = document.createElement('tbody');
  pageRows.forEach(r => {
    const tr = document.createElement('tr');
    const cells = previewCellsFromRow(r); // reuse highlighting
    cells.forEach(cell => { const td = document.createElement('td'); if (cell.html) td.innerHTML=cell.html; else td.textContent = cell.value; tr.appendChild(td); });
    tbody.appendChild(tr);
  });
  tbl.appendChild(thead); tbl.appendChild(tbody);
  wrap.innerHTML=''; wrap.appendChild(tbl);
  // Update stats
  setStats({ rows: allRows.length });
}

function setViewMode(mode){
  VIEW_MODE = mode; renderResults();
}

function onFilterChange(val){ TABLE_STATE.filter = val; TABLE_STATE.page = 1; renderResultsTable(); }
function onPageSizeChange(val){ TABLE_STATE.perPage = parseInt(val,10)||50; TABLE_STATE.page = 1; renderResultsTable(); }
function onHeaderSort(index){
  if (TABLE_STATE.sortIndex === index){ TABLE_STATE.sortDir = TABLE_STATE.sortDir === 'asc' ? 'desc' : 'asc'; }
  else { TABLE_STATE.sortIndex = index; TABLE_STATE.sortDir = 'asc'; }
  renderResultsTable();
}
function nextPage(){ TABLE_STATE.page += 1; renderResultsTable(); }
function prevPage(){ TABLE_STATE.page = Math.max(1, TABLE_STATE.page - 1); renderResultsTable(); }

function updateDownloadState(){
  const anyIncluded = CURRENT_RESULTS.some(r => r.include);
  toggleDownload(anyIncluded);
}

function toggleDownload(enabled){
  document.getElementById('downloadBtn').disabled = !enabled;
  document.getElementById('downloadBtn2').disabled = !enabled;
}

function setStats(partial){
  if (partial.files != null) document.getElementById('statFiles').textContent = `${partial.files} file${partial.files===1?'':'s'}`;
  if (partial.tables != null) document.getElementById('statTables').textContent = `${partial.tables} table${partial.tables===1?'':'s'}`;
  if (partial.rows != null) document.getElementById('statRows').textContent = `${partial.rows} row${partial.rows===1?'':'s'}`;
}

function setProgress(text){
  document.getElementById('progress').textContent = text || '';
}

function headersForCSV(){
  const base = ["Entity","Category","Title","Article_ID","Path","Type","Area","Sub Area","TAT"];
  const tail = REUSE_CONTINGENCY_FOR_SCENARIO ? ["Contingency","NewSRTemplate","NewSRFlagged"] : ["Contingency","Scenario","NewSRTemplate","NewSRFlagged"];
  return [...base, ...tail];
}

function csvRowFromObj(r){
  const contingencyOut = REUSE_CONTINGENCY_FOR_SCENARIO ? (r.scenario || r.contingency || '') : (r.contingency || '');
  const scenarioOut = REUSE_CONTINGENCY_FOR_SCENARIO ? undefined : (r.scenario || '');
  const parts = [
    r.entity,
    r.cleanArticleCategory,
    r.titlePath,
    r.articleId,
    r.articleURL,
    r.type,
    r.area,
    r.subArea,
    r.tat,
  ];
  if (REUSE_CONTINGENCY_FOR_SCENARIO) {
    parts.push(contingencyOut);
  } else {
    parts.push(contingencyOut); // contingency
    parts.push(scenarioOut);    // scenario
  }
  parts.push(r.newSrTemplate);
  parts.push(r.isFlagged);
  return parts.map(v => (ENABLE_EXCEL_SANITIZE ? sanitizeForExcel(v) : v) || '');
}

function buildCSVContent(){
  const header = headersForCSV();
  let csv = '\uFEFF' + header.join(',') + '\n';
  CURRENT_RESULTS.filter(r => r.include).forEach(item => {
    item.rows.forEach(r => {
      const row = csvRowFromObj(r).map(csvEscape).join(',');
      csv += row + '\n';
    });
  });
  return csv;
}

function downloadCurrentCSV(){
  const csv = buildCSVContent();
  downloadCSV(csv);
}

function previewCellsFromRow(r){
  const parts = csvRowFromObj(r);
  const headers = headersForCSV();
  // We will highlight matches only in Type (and Area/Sub Area as a nice bonus)
  const indexMap = {};
  headers.forEach((h,i)=> indexMap[h]=i);
  const fieldsToCheck = ['Type','Area','Sub Area'];
  return parts.map((v, i) => {
    const h = headers[i];
    if (fieldsToCheck.includes(h) && v){
      const html = highlightMatches(String(v));
      return { html };
    }
    return { value: v };
  });
}

function highlightMatches(text){
  const lower = text.toLowerCase();
  // Find all matching segments according to SR_KEYWORDS
  let segments = [];
  for (const rawKw of SR_KEYWORDS){
    if (!rawKw || rawKw === '*') continue;
    const isWild = rawKw.endsWith('*');
    const needle = (isWild ? rawKw.slice(0,-1) : rawKw).toLowerCase();
    if (!needle) continue;
    // Find all occurrences (global contains)
    let from = 0;
    while (true){
      const idx = lower.indexOf(needle, from);
      if (idx === -1) break;
      segments.push({ start: idx, end: idx + needle.length });
      from = idx + needle.length;
    }
  }
  if (!segments.length) return escapeHtml(text);
  // Merge overlapping segments
  segments.sort((a,b)=> a.start - b.start);
  const merged = [];
  for (const s of segments){
    if (!merged.length || s.start > merged[merged.length-1].end){ merged.push({...s}); }
    else { merged[merged.length-1].end = Math.max(merged[merged.length-1].end, s.end); }
  }
  // Build HTML
  let out = '';
  let cursor = 0;
  for (const s of merged){
    if (cursor < s.start) out += escapeHtml(text.slice(cursor, s.start));
    out += '<span class="hit">' + escapeHtml(text.slice(s.start, s.end)) + '</span>';
    cursor = s.end;
  }
  if (cursor < text.length) out += escapeHtml(text.slice(cursor));
  return out;
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

function triggerImportKeywords(){
  const inp = document.getElementById('keywordImportFile');
  inp.onchange = async () => {
    const f = inp.files && inp.files[0];
    if (!f) return;
    try{
      const text = await f.text();
      const json = JSON.parse(text);
      applyImportedKeywords(json);
    }catch(e){ alert('Invalid JSON file'); }
    finally{ inp.value=''; }
  };
  inp.click();
}

function applyImportedKeywords(json){
  // Accept either { keywords: [] } or [..] directly
  let list = Array.isArray(json) ? json : (Array.isArray(json.keywords) ? json.keywords : null);
  if (!list){ alert('JSON must be an array or {keywords: []}'); return; }
  const parsed = list.map(x=>String(x||'').toLowerCase().trim()).filter(Boolean);
  SR_KEYWORDS = Array.from(new Set(parsed));
  renderChips();
}

function exportKeywords(){
  const data = { keywords: SR_KEYWORDS };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='sr_keywords.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}

function toggleBulkPanel(){
  const panel = document.getElementById('bulkPastePanel');
  panel.style.display = (panel.style.display === 'none' || !panel.style.display) ? 'block' : 'none';
}

function applyBulkKeywords(){
  const ta = document.getElementById('bulkTextarea');
  const parsed = parseKeywords(ta.value);
  if (!parsed.length){ alert('No keywords found'); return; }
  SR_KEYWORDS = Array.from(new Set(parsed));
  renderChips();
}

/** =========================
 *  HELPERS
 *  ========================= */
function isSparseTable(rows){
  const firstRow = [...rows].find(r => r.querySelectorAll('td').length);
  const n = firstRow ? firstRow.querySelectorAll('td').length : 0;
  return n > 0 && n <= 2;
}

function extractKey(input) {
  if (!input) return null;
  // try "/endb/<key>" first
  let m = input.match(/\/endb\/([\w-]+)/i);
  if (m) return m[1];
  // then "endb: <key>"
  m = input.match(/endb[:\s]+([\w-]+)/i);
  return m ? m[1] : null;
}

function normalizeText(s) {
  return (s || "")
    .replace(/\u00A0/g, " ")   // NBSP -> space
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}

function normalizeCell(td) {
  // Prefer visible text; fall back to link href if content is empty
  let txt = (td.textContent || "").replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
  if (!txt) {
    const a = td.querySelector("a[href]");
    if (a) txt = a.href || "";
  }
  return txt;
}

function safePick(pickFn, idx) {
  return (idx != null) ? pickFn(idx) : "";
}

function detectTemplateCell(tr) {
  // Look for explicit template mentions or links
  const tds = tr.querySelectorAll("td");
  for (const td of tds) {
    const text = normalizeText(td.textContent);
    if (/template/.test(text)) {
      const link = td.querySelector("a[href]");
      return link ? (link.href || link.textContent || "").trim() : (td.textContent || "").trim();
    }
    const a = td.querySelector("a[href]");
    if (a && /template|\.docx$|\.xlsx$|\.xls$|\.pdf$/i.test(a.href || "")) {
      return a.href;
    }
  }
  return "";
}

function csvEscape(s) {
  s = (s ?? "").toString();
  if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
  return s;
}

// Replace common Unicode punctuation that often appears corrupted (mojibake) in Excel when encoding is mis-detected
// This is defensive; with the BOM Excel should decode correctly, but this keeps output ASCII-friendly.
function sanitizeForExcel(s) {
  if (s == null) return '';
  return s
    .replace(/[\u2018\u2019\u201A\u201B]/g, "'") // curly/single quotes
    .replace(/[\u201C\u201D\u201E]/g, '"')       // curly double quotes
    .replace(/[\u2013\u2014\u2015]/g, '-')       // dashes
    .replace(/\u2022/g, '*')                      // bullet
    .replace(/\u00A0/g, ' ')                      // NBSP
    .replace(/[\u2026]/g, '...')                  // ellipsis
    .replace(/[\u2122]/g, 'TM')                   // trademark
    .replace(/[\u00AE]/g, '(R)')                  // registered
    .replace(/[\u00A9]/g, '(C)');                 // copyright
}

function downloadCSV(content) {
  const blob = new Blob([content], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "combined_serviceRequests.csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = e => reject(e);
    reader.readAsText(file);
  });
}

/** =========================
 *  METADATA SCRAPER (dt/dd up the DOM)
 *  ========================= */
function findMetaNearby(startNode, key) {
  const target = (key || "").toLowerCase();
  let node = startNode;
  let safety = 0;
  while (node && safety++ < 20) {
    const dts = node.querySelectorAll("dt");
    for (const dt of dts) {
      if (normalizeText(dt.textContent) === target) {
        const dd = dt.nextElementSibling;
        if (dd && dd.tagName === "DD") {
          return (dd.textContent || "").replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
        }
      }
    }
    node = node.parentElement;
  }
  return null;
}

  </script>
</body>
</html>