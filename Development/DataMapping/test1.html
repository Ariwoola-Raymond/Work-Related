<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Mapping</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

</head>

<body>
    <h1>Department Data Mapping</h1>
    <input type="file" id="upload" accept=".csv" />
    <script>
        let mappingRules = null;

        // Load mapping rules before allowing file processing
        async function loadMappingRules() {
            try {
                const response = await fetch('mappings.json');
                mappingRules = await response.json();
                document.getElementById('upload').disabled = false;
            } catch (error) {
                console.error('Failed to load mapping rules:', error);
                alert('Failed to load mapping rules. Please refresh the page.');
            }
        }

        function matchConditions(row, conditions) {
            return Object.entries(conditions).every(([key, value]) => {
                if (Array.isArray(value)) {
                    return value.some(v => containsAllWords(row[key], v));
                }
                return caseInsensitiveCompare(row[key], value);
            });
        }

        function applyOutput(row, output) {
            Object.entries(output).forEach(([key, value]) => {
                row[key] = value;
            });
        }

        function processRow(row) {
            let newRow = { ...row };
            let groupContext = null;

            // Apply entity/division rules
            for (const group of mappingRules.mappingGroups) {
                const matchedRule = group.entityDivisionRules.find(rule => 
                    matchConditions(row, rule.conditions)
                );

                if (matchedRule) {
                    applyOutput(newRow, matchedRule.output);
                    groupContext = group.name;
                    break;
                }
            }

            // Apply group-specific rules
            const activeGroup = mappingRules.mappingGroups.find(g => g.name === groupContext);
            if (activeGroup) {
                // Apply department rules if they exist
                if (activeGroup.departmentRules) {
                    const deptRule = activeGroup.departmentRules.find(rule => 
                        matchConditions(row, rule.conditions)
                    );
                    if (deptRule) applyOutput(newRow, deptRule.output);
                }

                // Apply role/position rules
                if (activeGroup.roleRules) {
                    const roleRule = activeGroup.roleRules.find(rule => 
                        matchConditions(row, rule.conditions)
                    );
                    if (roleRule) applyOutput(newRow, roleRule.output);
                }

                if (activeGroup.positionRules) {
                    const posRule = activeGroup.positionRules.find(rule => 
                        matchConditions(row, rule.conditions)
                    );
                    if (posRule) applyOutput(newRow, posRule.output);
                }
            }

            return newRow;
        }

        function containsAllWords(inputString, searchPhrase) {
            if (!inputString || !searchPhrase) return false;
            const inputWords = inputString.toLowerCase().split(/\s+/);
            const searchWords = searchPhrase.toLowerCase().split(/\s+/);
            return searchWords.every(searchWord => 
                inputWords.some(inputWord => inputWord.includes(searchWord))
            );
        }

        function caseInsensitiveCompare(input, target) {
            return input?.toLowerCase() === target?.toLowerCase();
        }

        function processCSV(inputFile, callback) {
            Papa.parse(inputFile, {
                header: true,
                skipEmptyLines: true,
                complete: function (results) {
                    const inputRows = results.data;

                    console.log("Input Rows:", inputRows);

                    const transformedData = inputRows.map(processRow);

                    console.log("Transformed Data:", transformedData);

                    callback(transformedData);
                }
            });
        }

        function reorderColumns(data) {
            return data.map(row => {
                return {
                    "Campaign.Entity": row["Campaign.Entity"],
                    "Campaign.Division": row["Campaign.Division"],
                    "Campaign.Department": row["Campaign.Department"],
                    "Campaign.Role": row["Campaign.Role"], ...row
                };
            });
        }

        function downloadCSV(data) {
            const reorderedData = reorderColumns(data);
            const csv = Papa.unparse(reorderedData);
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "transformed_data.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById("upload").disabled = true; // Disable until rules are loaded
        loadMappingRules(); // Load rules when page loads
        document.getElementById("upload").addEventListener("change", function(event) {
            if (!mappingRules) {
                alert('Mapping rules not loaded yet. Please wait.');
                return;
            }
            const file = event.target.files[0];
            processCSV(file, transformedData => {
                downloadCSV(transformedData);
            });
        });

    </script>
</body>

</html>